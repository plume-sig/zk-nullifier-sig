/// This crate provides the PLUME signature scheme.
///
/// See <https://blog.aayushg.com/nullifier> for more information.
/// 
/// Find RustCrypto crate as `plume_rustcrypto`.

pub use crate::error::HashToCurveError;
use crate::hash_to_curve::hash_to_curve;

/// Re-exports the `GroupAffine` and `SWModelParameters` types from the `ark_ec` crate.
///
/// `GroupAffine` represents an affine point on a short Weierstrass elliptic curve.
/// `SWModelParameters` contains the parameters defining a short Weierstrass curve.
pub use ark_ec::{models::SWModelParameters, short_weierstrass_jacobian::GroupAffine};
/// Re-exports the `Rng` trait from the `rand` crate in `ark_std`.
///
/// `Rng` provides methods for generating random values.
pub use ark_std::rand::Rng;

use ark_ec::{AffineCurve, ProjectiveCurve};
use ark_ff::PrimeField;
use ark_serialize::{CanonicalDeserialize, CanonicalSerialize, Read, SerializationError, Write};
use ark_std::UniformRand;
use secp256k1::sec1::Sec1EncodePoint;
use sha2::digest::Output;
use sha2::{Digest, Sha256};

mod error;
mod hash_to_curve;

const EXPECT_MSG_DECODE: &str = "the value decoded have been generated by a function which is improbable to output a malformed hexstring (still a place for refactoring)";

/// An `enum` representing the variant of the PLUME protocol.
pub enum PlumeVersion {
    V1,
    V2,
}

/// Converts an affine point on the curve to the byte representation.
///
/// Serializes the affine point to its SEC1 encoding and returns the raw bytes.
pub fn affine_to_bytes<P: SWModelParameters>(point: &GroupAffine<P>) -> Vec<u8> {
    hex::decode(point.to_encoded_point(true))
        .expect(EXPECT_MSG_DECODE)
        .to_vec()
}

fn compute_h<'a, C: ProjectiveCurve, Fq: PrimeField, P: SWModelParameters>(
    pk: &GroupAffine<P>,
    message: &'a [u8],
) -> Result<GroupAffine<P>, HashToCurveError> {
    //let pk_affine_bytes_vec = affine_to_bytes::<P>(pk);
    //let m_pk = [message, pk_affine_bytes_vec.as_slice()].concat();
    //hash_to_curve::try_and_increment::<C>(m_pk.as_slice())
    hash_to_curve::<Fq, P>(message, pk)
}

fn compute_c_v1<P: SWModelParameters>(
    g_point: &GroupAffine<P>,
    pk: &GroupAffine<P>,
    hashed_to_curve: &GroupAffine<P>,
    nullifier: &GroupAffine<P>,
    r_point: &GroupAffine<P>,
    hashed_to_curve_r: &GroupAffine<P>,
) -> Output<Sha256> {
    // Compute c = sha512([g, pk, h, nul, g^r, z])
    let c_preimage_vec = [
        affine_to_bytes::<P>(g_point),
        affine_to_bytes::<P>(pk),
        affine_to_bytes::<P>(hashed_to_curve),
        affine_to_bytes::<P>(nullifier),
        affine_to_bytes::<P>(r_point),
        affine_to_bytes::<P>(hashed_to_curve_r),
    ]
    .concat();

    Sha256::digest(c_preimage_vec.as_slice())
}

fn compute_c_v2<P: SWModelParameters>(
    nullifier: &GroupAffine<P>,
    r_point: &GroupAffine<P>,
    hashed_to_curve_r: &GroupAffine<P>,
) -> Output<Sha256> {
    // Compute c = sha512([nul, g^r, z])
    let nul_bytes = affine_to_bytes::<P>(nullifier);
    let g_r_bytes = affine_to_bytes::<P>(r_point);
    let z_bytes = affine_to_bytes::<P>(hashed_to_curve_r);

    let c_preimage_vec = [nul_bytes, g_r_bytes, z_bytes].concat();

    Sha256::digest(c_preimage_vec.as_slice())
}

/// A struct containing parameters for the SW model, including the generator point `g_point`.
/// This struct implements traits for (de)serialization.
#[derive(
    Copy,
    Clone,
    ark_serialize_derive::CanonicalSerialize,
    ark_serialize_derive::CanonicalDeserialize,
)]
pub struct Parameters<P: SWModelParameters> {
    /// The generator point for the SW model parameters.
    pub g_point: GroupAffine<P>,
}

/// A struct containing the PLUME signature data
#[derive(
    Copy,
    Clone,
    ark_serialize_derive::CanonicalSerialize,
    ark_serialize_derive::CanonicalDeserialize,
)]
pub struct PlumeSignature<P: SWModelParameters> {
    /// The hash-to-curve output multiplied by the random `r`.  
    pub hashed_to_curve_r: GroupAffine<P>,
    /// The randomness `r` represented as the curve point.
    pub r_point: GroupAffine<P>,
    pub s: P::ScalarField,
    pub c: P::ScalarField,
    /// The nullifier.
    pub nullifier: GroupAffine<P>,
}

// These aliases should be gone in #88 . If they won't TODO pay attention to the warning about `trait` boundaries being not checked for aliases
//      also not enforcing trait bounds can impact PublicKey -- it's better to find appropriate upstream type

/// A type alias for a byte slice reference, used for representing the message.
pub type Message<'a> = &'a [u8];
/// The public key.
pub type PublicKey<P: SWModelParameters> = GroupAffine<P>;
/// The scalar field element representing the secret key.
pub type SecretKeyMaterial<P: SWModelParameters> = P::ScalarField;

impl<P: SWModelParameters> PlumeSignature<P> {
    /// Generate the public key and a private key.
    /// # HAZMAT
    /// No measures yet taken for the [`SecretKeyMaterial`] protection
    pub fn keygen(pp: &Parameters<P>, rng: &mut impl Rng) -> (PublicKey<P>, SecretKeyMaterial<P>) {
        let secret_key = SecretKeyMaterial::<P>::rand(rng);
        let public_key = pp.g_point.mul(secret_key).into();
        (public_key, secret_key)
    }

    /// Sign a message using the specified `r` value
    fn sign_with_r(
        pp: &Parameters<P>,
        keypair: (&PublicKey<P>, &SecretKeyMaterial<P>),
        message: Message,
        r_scalar: P::ScalarField,
        version: PlumeVersion,
    ) -> Result<Self, HashToCurveError> {
        let g_point = pp.g_point;
        let r_point = g_point.mul(r_scalar).into_affine();

        // Compute h = htc([m, pk])
        let hashed_to_curve =
            compute_h::<secp256k1::Projective, secp256k1::fields::Fq, P>(&keypair.0, &message)?;

        // Compute z = h^r
        let hashed_to_curve_r = hashed_to_curve.mul(r_scalar).into_affine();

        // Compute nul = h^sk
        let nullifier = hashed_to_curve.mul(*keypair.1).into_affine();

        // Compute c = sha512([g, pk, h, nul, g^r, z])
        let c = match version {
            PlumeVersion::V1 => compute_c_v1::<P>(
                &g_point,
                keypair.0,
                &hashed_to_curve,
                &nullifier,
                &r_point,
                &hashed_to_curve_r,
            ),
            PlumeVersion::V2 => compute_c_v2(&nullifier, &r_point, &hashed_to_curve_r),
        };
        let c_scalar = P::ScalarField::from_be_bytes_mod_order(c.as_ref());
        // Compute s = r + sk ⋅ c
        let sk_c = keypair.1.into_repr().into() * c_scalar.into_repr().into();
        let s = r_scalar.into_repr().into() + sk_c;

        let s_scalar = P::ScalarField::from(s);

        let signature = PlumeSignature {
            hashed_to_curve_r,
            s: s_scalar,
            r_point,
            c: c_scalar,
            nullifier,
        };
        Ok(signature)
    }

    /// Sign a message.
    fn sign(
        pp: &Parameters<P>,
        rng: &mut impl Rng,
        keypair: (&PublicKey<P>, &SecretKeyMaterial<P>),
        message: Message,
        version: PlumeVersion,
    ) -> Result<Self, HashToCurveError> {
        // Pick a random r from Fp
        let r_scalar = P::ScalarField::rand(rng);

        Self::sign_with_r(pp, keypair, message, r_scalar, version)
    }

    /// Verifies a PLUME signature.
    /// Returns `true` if the signature is valid, `false` otherwise.
    ///
    /// Computes the curve points and scalars needed for verification from the
    /// signature parameters. Then performs the verification steps:
    /// - Confirm g^s * pk^-c = g^r
    /// - Confirm h^s * nul^-c = z
    /// - Confirm c = c'
    ///
    /// Rejects if any check fails.
    fn verify_non_zk(
        self,
        pp: &Parameters<P>,
        pk: &PublicKey<P>,
        message: Message,
        version: PlumeVersion,
    ) -> Result<bool, HashToCurveError> {
        // Compute h = htc([m, pk])
        let hashed_to_curve =
            compute_h::<secp256k1::Projective, secp256k1::fields::Fq, P>(pk, message)?;

        // TODO [replace SHA-512](https://github.com/plume-sig/zk-nullifier-sig/issues/39#issuecomment-1732497672)
        // Compute c' = sha512([g, pk, h, nul, g^r, z]) for v1
        //         c' = sha512([nul, g^r, z]) for v2
        let c = match version {
            PlumeVersion::V1 => compute_c_v1::<P>(
                &pp.g_point,
                pk,
                &hashed_to_curve,
                &self.nullifier,
                &self.r_point,
                &self.hashed_to_curve_r,
            ),
            PlumeVersion::V2 => {
                compute_c_v2(&self.nullifier, &self.r_point, &self.hashed_to_curve_r)
            }
        };
        let c_scalar = P::ScalarField::from_be_bytes_mod_order(c.as_ref());

        // Reject if g^s ⋅ pk^{-c} != g^r
        let g_s = pp.g_point.mul(self.s);
        let pk_c = pk.mul(self.c);
        let g_s_pk_c = g_s - pk_c;

        if self.r_point != g_s_pk_c {
            return Ok(false);
        }

        // Reject if h^s ⋅ nul^{-c} = z
        let h_s = hashed_to_curve.mul(self.s);
        let nul_c = self.nullifier.mul(self.c);
        let h_s_nul_c = h_s - nul_c;

        if self.hashed_to_curve_r != h_s_nul_c {
            return Ok(false);
        }

        // Reject if c != c'
        if c_scalar != self.c {
            return Ok(false);
        }

        Ok(true)
    }
}

#[cfg(test)]
mod tests;
